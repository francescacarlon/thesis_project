{
    "T2": {
        "instance_code": "T2",
        "original_category": "L",
        "original_text_title": "Constituency and Context-Free Grammars",
        "original_text": "Syntactic constituency is the idea that groups of words can behave as single units, or constituents. Consider the noun phrase, a sequence of words surrounding at least one noun. [...] they can all appear in similar syntactic environments, for example, before a verb: 'three parties from Brooklyn arrive'. [...] A widely used formal system for modeling constituent structure in natural language is the context-free grammar (CFG). [...] A context-free grammar consists of a set of rules or productions, each of which expresses the ways that symbols of the language can be grouped and ordered together, and a lexicon of words and symbols. [...] an NP (or noun phrase) can be composed of either a ProperNoun or a determiner (Det) followed by a Nominal; [...]. Context-free rules can be hierarchically  embedded, [...]: Det → a, Det → the, Noun → flight. [...] Thus, a CFG can be used to generate a set of strings. This sequence of rule expansions is called a derivation of the string of words. It is common to represent a derivation by a parse tree (commonly shown inverted with the root at the top). [...]. A CFG like that of L0 defines a formal language. Sentences (strings of words) that can be derived by a grammar are in the formal language defined by that grammar, and are called grammatical sentences. Sentences that cannot be derived by a given formal grammar are not in the language defined by that grammar and are  referred to as ungrammatical. [...] In linguistics, the use of formal languages to model natural languages is called generative grammar [...].",
        "selected_texts": {
            "CS": {
                "CS_gpt4o_prompt2": "Syntactic constituency is the concept that certain groups of words function as single units, known as constituents, in a sentence. Consider a noun phrase, which is a sequence of words centered around at least one noun. For example, in the sentence 'three parties from Brooklyn arrive,' 'three parties from Brooklyn' behaves as a single unit before the verb 'arrive.'\n\nA common way to model these structures in natural language is by using a context-free grammar (CFG). A CFG is a formal system that uses a set of rules, or productions, to show how symbols (words) can be grouped and ordered. It includes a lexicon, which is like a dictionary of words and symbols. For instance, a noun phrase (NP) can be made up of a proper noun or a determiner followed by a nominal. Here's an example of some context-free rules: Det → a, Det → the, Noun → flight.\n\nThese rules can be applied in a hierarchical manner, meaning they can be nested within each other. Using a CFG, you can generate a set of strings, which is a sequence of rule applications known as a derivation. This can be visually represented as a parse tree, typically shown with the root at the top.\n\nA CFG, such as L0, defines a formal language. Sentences that can be derived using the grammar are considered part of the formal language and are called grammatical. Those that cannot be derived are ungrammatical. In the field of linguistics, using formal languages like CFGs to model natural languages is known as generative grammar.",
                "CS_mistral_prompt4": "\"In natural language processing, syntactic constituency refers to the concept of grouping words together to form meaningful units or constituents, such as noun phrases. For instance, a noun phrase might consist of a determiner (like 'a' or 'the') and a noun (like 'flight'). These groupings can appear in similar structures, such as before a verb, as in the example 'three parties from Brooklyn arrive'.\n\n     A widely used formal system for modeling these constituent structures is the Context-Free Grammar (CFG), which consists of a set of rules for arranging symbols and words, and a lexicon of words and symbols. An example of a CFG rule might be Det → a, Det → the, and Noun → flight.\n\n     These rules can be hierarchically embedded, allowing for more complex structures to be generated. For example, the rule Det → Det Noun could be used to create a more complex noun phrase like 'the flight'.\n\n     The application of a CFG results in a derivation, or sequence of rule expansions, which can be represented by a parse tree, with the root at the top. This tree structure defines a formal language, and sentences that can be derived by the grammar are considered grammatical, while those that cannot are referred to as ungrammatical.\n\n     This approach of using formal languages to model natural languages is known as generative grammar in linguistics.\""
            }
        }
    },
    "T3": {
        "instance_code": "T3",
        "original_category": "L",
        "original_text_title": "Semantic Roles and Diathesis Alternations",
        "original_text": "Consider the meanings of the arguments Sasha, Pat, the window, and the door in these two sentences. Sasha broke the window. Pat opened the door. The subjects Sasha and Pat, what we might call the breaker of the window breaking event and the opener of the door-opening event, have something in common. They are both volitional actors, often animate, and they have direct causal responsibility for their events. Thematic roles are a way to capture this semantic commonality between breakers and openers. We say that the subjects of both these verbs are agents. Thus, AGENT is the thematic role that represents an abstract idea such as volitional causation. Similarly, the direct objects of both these verbs, the BrokenThing and OpenedThing, are both prototypically inanimate objects that are affected in some way by the action. The semantic role for these participants is theme. [...] Semantic roles thus help generalize over different surface realizations of predicate arguments. For example, while the AGENT is often realized as the subject of the sentence, in other cases the THEME can be the subject. [...] John (AGENT) broke the window (THEME). John (AGENT) broke the window (THEME) with a rock (INSTRUMENT). The rock (INSTRUMENT) broke the window (THEME). The window (THEME) broke. The window (THEME) was broken by John (AGENT). These examples suggest that break has (at least) the possible arguments AGENT, THEME, and INSTRUMENT. [...] These multiple argument structure realizations [...] are called verb alternations or diathesis alternations.",
        "selected_texts": {
            "CS": {
                "CS_llama_prompt5": "In the realm of Computer Science, you're likely familiar with concepts like object-oriented programming and design patterns. Think of semantic roles as a way to define abstract classes or interfaces that capture common behaviors or characteristics across different entities. Just as an interface in Java defines a contract that must be implemented by any class that implements it, semantic roles define a set of properties or behaviors that are shared by entities in a sentence. In the context of natural language processing, these entities can be thought of as \"objects\" that play specific roles in a \"scene\" or sentence. The AGENT role, for example, represents an entity that performs an action, much like a class that implements an interface for a specific action. The THEME role represents an entity that is affected by the action, similar to an object that is modified by a method call. Just as you might have multiple classes that implement the same interface, you can have multiple entities that play the same semantic role in different sentences. The concept of verb alternations or diathesis alternations can be thought of as different implementations of the same interface, where the same action or verb can be realized in different ways, with different entities playing different roles. For instance, in the sentence \"John broke the window,\" John is the AGENT and the window is the THEME. But in the sentence \"The window was broken by John,\" the window is still the THEME, but it's now the subject of the sentence, illustrating how the same entity can play different roles in different contexts. This is similar to how a class can implement multiple interfaces, or how an object can be used in different contexts, playing different roles. By recognizing these semantic roles and their relationships, you can better understand the structure and meaning of natural language, much like how you would analyze the design patterns and interfaces in a software system.",
                "CS_deepseek_prompt2": "Thematic roles are like abstract data types that categorize arguments based on their function in an event. Think of them as semantic interfaces – different noun phrases implement these roles depending on their relationship to the verb.  \n\nIn \"Sasha broke the window\" and \"Pat opened the door\":  \n- **Sasha/Pat** = AGENT (volitional initiator, like a `main()` function triggering an action)  \n- **window/door** = THEME (object being modified, similar to a parameter passed by reference)  \n\nThese roles persist even when syntax changes, just like how a variable's memory address matters more than its identifier. For example:  \n1. `break(agent=John, theme=window)` ➔ \"John broke the window\"  \n2. `break(theme=window)` ➔ \"The window broke\" (agent omitted like a default parameter)  \n3. `break(instrument=rock, theme=window)` ➔ \"The rock broke the window\" (instrument promoted to subject position)  \n\nThis syntactic flexibility is called **verb alternation** – similar to method overloading where the same operation accepts different argument structures. Recognizing these patterns helps NLP systems parse meaning independently of surface syntax, like maintaining invariants across different algorithm implementations."
            }
        }
    },
    "T4": {
        "instance_code": "T4",
        "original_category": "L",
        "original_text_title": "Word Senses and Relations Between Senses",
        "original_text": "A sense (or word sense) is a discrete representation of one aspect of the meaning of a word. [...] In context, it's easy to see the different meanings: mouse1: a mouse controlling a computer system in 1968. mouse2: a quiet animal like a mouse. bank1: a bank can hold the investments in a custodial account. bank2: as agriculture burgeons on the east bank, the river...[...] we need to consider the alternative ways that dictionaries and thesauruses offer for defining senses. One is based on the fact that dictionaries or thesauruses give textual definitions for each sense called glosses. [...] bank: 1. financial institution that accepts deposits and channels the money into lending activities 2. sloping land (especially the slope beside a body of water). [...] when two senses of two different words (lemmas) are identical, or nearly identical, we say the two senses are synonyms [...] couch/sofa vomit/throw up filbert/hazelnut car/automobile. [...] antonyms are words with an opposite meaning, like: long/short big/little fast/slow cold/hot dark/light. [...] [a] hyponym of [a] word if the [other word] is more specific, denoting a subclass of the other. For example, car is a hyponym of vehicle, dog is a hyponym of animal, [...]. Conversely, we say that vehicle is a hypernym of car, and animal is a hypernym of dog. [...] meronymy, the part-whole relation. [...] wheel is a meronym of car, and car is a holonym of wheel.",
        "selected_texts": {
            "CS": {
                "CS_mistral_prompt1": "1. In the realm of Computer Science, understanding word senses is crucial. Each sense represents a unique facet of a word's meaning.\n\n    2. For example, consider the words 'mouse' and 'bank'. In the context of programming, 'mouse' refers to the input device that controls a cursor on the screen. 'Bank', on the other hand, can denote a financial institution that manages money transactions.\n\n    3. Dictionaries and thesauruses help define these senses using textual definitions called 'glosses'. For example, the gloss for 'bank' would be something like: \"a financial institution that accepts deposits and channels money into lending activities\".\n\n    4. When two words share identical or nearly identical meanings, we call them synonyms. For instance, 'couch' and 'sofa' are synonyms, as are 'filbert' and 'hazelnut'.\n\n    5. Conversely, antonyms are words with opposite meanings. For example, 'long' and 'short', 'big' and 'little', 'fast' and 'slow', 'cold' and 'hot', and 'dark' and 'light' are all pairs of antonyms.\n\n    6. A hyponym is a word that is more specific and denotes a subclass of another word. For example, 'car' is a hyponym of 'vehicle', meaning that a car is a type of vehicle.\n\n    7. On the flip side, we call the other word a hypernym. For instance, 'vehicle' is a hypernym of 'car', as it encompasses all types of vehicles, not just cars.\n\n    8. Lastly, meronymy is the relationship between a part and a whole. For example, in a car, the 'wheel' is a part, and the 'car' is the whole. In this case, the car is the holonym of the wheel.",
                "CS_deepseek_prompt3": "In natural language processing, think of **word senses** as different \"function overloads\" for the same word. Just like `sort()` might handle arrays vs. linked lists differently, the word \"mouse\" switches meaning based on context:  \n- `mouse(context=\"tech\")` → computer device  \n- `mouse(context=\"nature\")` → small rodent  \n\n**Synonyms** are like aliases for the same concept—different variable names pointing to the same object (e.g., `couch`/`sofa` or `vomit`/`throw_up`). **Antonyms** are boolean opposites: `dark`/`light` works like `is_dark = !is_light`.  \n\n**Hyponyms** and **hypernyms** mirror class inheritance:  \n- `Car` *inherits from* `Vehicle` → \"car\" is a hyponym of \"vehicle\"  \n- `Vehicle` *is a superclass of* `Car` → \"vehicle\" is a hypernym of \"car\"  \n\n**Meronymy** describes object composition:  \n- `Wheel` is a component of `Car` → \"wheel\" is a meronym of \"car\"  \n- `Car` *has-a* `Wheel` → \"car\" is a holonym of \"wheel\"  \n\nDictionaries act like key-value databases, where each sense (key) maps to a definition (value). Disambiguating senses is like resolving variable naming conflicts in a scope—the correct \"version\" depends on surrounding code (context)."
            }
        }
    },
    "T7": {
        "instance_code": "T7",
        "original_category": "CS",
        "original_text_title": " Training FFNNs (Loss Function and Gradient)",
        "original_text": "A feedforward neural net is an instance of supervised machine learning in which we know the correct output y for each observation x. What the system produces is ˆy, the system's estimate of the true y. The goal of the training procedure is to learn parameters W[i] and b[i] for each layer i that make ˆy for each training observation as close as possible to the true y. [...] First, we'll need a loss function that models the distance between the system output and the gold output, and it's common to use the loss function used for logistic regression, the cross-entropy loss. Second, to find the parameters that minimize this loss function, we'll use the gradient descent optimization algorithm [...]. Third, gradient descent requires knowing the gradient of the loss function, the vector that contains the partial derivative of the loss function with respect to each of the parameters. [...] for neural networks, with millions of parameters in many layers, it's much harder to see how to compute the partial derivative of some weight in layer 1 when the loss is attached to some much later layer. How do we partial out the loss over all those intermediate layers? The answer is the algorithm called error backpropagation or backward differentiation. [...] Computing the gradient requires the partial derivative of the loss function with respect to each parameter. [...] The solution to computing this gradient is an algorithm called error backpropagation.",
        "selected_texts": {
            "L": {
                "L_gpt4o_prompt5": "In linguistics terms, a feedforward neural network can be thought of as a system designed to predict an outcome based on a given input. Imagine it as a complex language model trying to translate a sentence. For every input sentence (x), we know the correct translation (y) and the model tries to produce its best guess (ŷ) of that translation.\n\nThe goal is to train this model so that its guess (ŷ) is as close as possible to the correct translation (y). To achieve this, it adjusts certain internal elements (let's call them parameters, similar to phonetic rules in a language) over several layers, each layer refining the guess based on the previous one.\n\nFirst, we need a way to measure the difference between the model's guess and the correct translation, much like evaluating how well a student has translated a sentence. We use a method called cross-entropy loss for this purpose, which is similar to assessing the semantic accuracy in translation.\n\nNext, to minimize this difference, we use an optimization technique called gradient descent. This is akin to gradually fine-tuning a grammar rule by observing many instances of its application.\n\nHowever, this process involves many parameters, like adjusting various phonetic and syntactic rules simultaneously, which can become complex in a large system. To effectively adjust these, we use a technique called error backpropagation. It's like retracing steps in a derivational tree to see how a change at one point affects the overall structure.\n\nIn essence, error backpropagation helps us understand how to tweak the phonetic and syntactic rules at various layers to improve the overall translation accuracy of the neural network.",
                "L_deepseek_prompt5": "A feedforward neural network operates like a supervised language learning task, where the system is trained on input-output pairs (x, y), akin to teaching a learner to map phonetic inputs (e.g., acoustic signals) to semantic outputs (e.g., word meanings). The network generates an estimate (ŷ) for each input, analogous to a language model predicting a syntactic structure for a sentence. Training adjusts \"weights\" (W[i]) and \"biases\" (b[i])—parameters acting like language-specific rules at different layers (phonological, morphological, etc.)—to minimize the mismatch between ŷ and y.  \n\nThe **loss function** (e.g., cross-entropy) quantifies this mismatch, much like measuring the divergence between a predicted phoneme sequence and its attested form. **Gradient descent** iteratively refines parameters, akin to adjusting phonological or syntactic rules to reduce errors in a language learner’s output. Crucially, computing how early-layer parameters (e.g., phonetic feature weights) contribute to later errors (e.g., semantic misinterpretations) requires **backpropagation**. This mirrors tracing a semantic error back through syntactic, morphological, and phonological layers to identify where the representation diverged, adjusting each layer’s \"rules\" accordingly. The process ensures coordinated learning across hierarchical linguistic levels, optimizing the entire system’s performance."
            }
        }
    },
    "T8": {
        "instance_code": "T8",
        "original_category": "CS",
        "original_text_title": "Backward Pass",
        "original_text": "The importance of the computation graph comes from the backward pass, which is used to compute the derivatives that we'll need for the weight update. [...] Backwards differentiation makes use of the chain rule [...]. Suppose we are computing the derivative of a composite function f(x) = u(v(x)). The derivative of f(x) is the derivative of u(x) with respect to v(x) times the derivative of v(x) with respect to x. [...] The chain rule extends to more than two functions. If computing the derivative of a composite function f(x) = u(v(w(x))), the derivative of f(x) is: df/dx = du/dv·dv/dw·dw/dx. The intuition of backward differentiation is to pass gradients back from the final node to all the nodes in the graph. [...] Each node takes an upstream gradient that is passed in from its parent node to the right, and for each of its inputs computes a local gradient (the gradient of its output with respect to its input), and uses the chain rule to multiply these two to compute a downstream gradient to be passed on to the next earlier node. Let's now compute the 3 derivatives we need. Since in the computation graph L = ce, we can directly compute the derivative ∂L/∂c: ∂L/∂c = e. For the other two, we'll need to use the chain rule: ∂L/∂a=∂L/∂e*∂e/∂a [and] ∂L/∂b=∂L/∂e*∂e/∂d*∂d/∂b.",
        "selected_texts": {
            "L": {
                "L_claude_prompt1": "Let me explain backward differentiation using concepts familiar to linguistics students:\n\nJust as we analyze sentences from larger structures down to their smallest components, backward differentiation works by starting from the final output and moving backwards through each step. Think of it like decomposing a complex sentence into its constituent parts.\n\nThe chain rule is similar to how we break down nested clauses in syntax trees. If we have a sentence with multiple embedded clauses, we need to understand how each clause relates to the others. Similarly, when we have a sequence of mathematical operations, we need to understand how changes in one part affect the whole.\n\nLet's use a linguistic analogy: Imagine analyzing how a change in word stress (x) affects the overall meaning of an utterance (f). If this relationship passes through intermediate effects on intonation (w), which affects phrase boundaries (v), which finally influences meaning (u), we need to consider each step's contribution. Just as meaning changes cascade through different linguistic levels, the chain rule shows us how changes flow backward through each calculation step.\n\nIn our computation graph, each node is like a morpheme that contributes to the final meaning. Just as a morpheme's meaning combines with others to create word meaning, each node takes information from later calculations (upstream) and passes modified information to earlier calculations (downstream), multiplying the effects at each step.\n\nWhen we calculate derivatives like ∂L/∂c, ∂L/∂a, and ∂L/∂b, we're essentially tracing back through our calculation path, similar to how we might trace semantic change through historical linguistics, seeing how each change influences the final result.",
                "L_mistral_prompt5": "1. The computation graph in machine learning is crucial for its backward pass, which calculates the needed derivatives for updating the weights during the learning process. The principal tool used in this process is chain rule from calculus.\n\n    2. Let's imagine a complex function f(x) that is the result of multiple operations u(v(x)). To calculate the derivative of this function, we use the chain rule. Specifically, the derivative of f(x) is the derivative of u(x) with respect to v(x) times the derivative of v(x) with respect to x.\n\n    3. Consider a simple example of the chain rule applied to a composite function f(x) = u(v(w(x))). The derivative of f(x) can be calculated as follows: df/dx = du/dv·dv/dw·dw/dx.\n\n    4. The chain rule's fundamental principle is that it allows us to \"pass\" the gradients from the final node backward through the entire graph. Each node in the graph receives an upstream gradient from its parent node, computes local gradients (gradients of the output with respect to its input), and then passes downstream gradients to the next earlier node using the chain rule.\n\n    5. Let's calculate the derivatives we need for our example. Suppose our computation graph is L = ce, the derivative of L with respect to c is straightforward: ∂L/∂c = e. To find the derivatives with respect to a and b, we'll use the chain rule: ∂L/∂a = ∂L/∂e * ∂e/∂a and ∂L/∂b = ∂L/∂e * ∂e/∂d * ∂d/∂b."
            }
        }
    },
    "T10": {
        "instance_code": "T10",
        "original_category": "CS",
        "original_text_title": "Long Short-Term Memory (LSTMs)",
        "original_text": "[...] it is quite difficult to train RNNs for tasks that require a network to make use of information distant from the current point of processing. [...] the information encoded in hidden states tends to be fairly local, more relevant to the most recent parts of the input sequence and recent decisions. [...] the gradients are eventually driven to zero, a situation called the vanishing gradients problem. To address these issues, more complex network architectures have been designed to explicitly manage the task of maintaining relevant context over time, by enabling the network to learn to forget information that is no longer needed and to remember information required for decisions still to come. The most commonly used such extension to RNNs is the long short-term memory (LSTM) network. LSTMs [...] remove information no longer needed from the context, and adding information likely to be needed for later decision making. [...] LSTMs accomplish this by first adding an explicit context layer to the architecture [...], and control the flow of information into and out of the units [...]. These gates are implemented through the use of additional weights that operate sequentially on the input, and previous hidden layer, and previous context layers. [...] The purpose of [the forget gate] is to delete information from the context that is no longer needed. [...] the add gate to select the information to add to the current context. [...] The final gate is the output gate which is used to decide what information is required for the current hidden state. [...]",
        "selected_texts": {
            "L": {
                "L_gpt4o_prompt3": "In the realm of neural networks, particularly Recurrent Neural Networks (RNNs), there's a challenge similar to understanding a sentence where key information is spread out. RNNs often struggle with remembering details from earlier in a sequence, much like trying to recall the beginning of a long sentence while reading the end. This happens because the information stored in the network's memory, or \"hidden states,\" tends to focus on recent input, akin to emphasizing the last few words you've just read. This can lead to the \"vanishing gradients problem,\" where early information fades away, much like how earlier parts of a conversation might become hazy.\n\nTo tackle this, an advanced version of RNNs called Long Short-Term Memory networks (LSTMs) was developed. Imagine LSTMs as having a more sophisticated memory system that can decide what to forget and what to remember, similar to how you might choose to remember a phone number but forget a random number you just heard. LSTMs achieve this through a series of \"gates,\" which are mechanisms that control the flow of information.\n\nFirstly, there's the \"forget gate,\" which clears out unnecessary information, like erasing irrelevant details. Then there's the \"add gate,\" which selects new information to store, akin to jotting down important notes. Finally, the \"output gate\" determines what information is essential for the current task, much like choosing the right words when forming a sentence. By using these gates, LSTMs manage to maintain relevant context over time, allowing them to handle sequences where information is scattered across various points, much like understanding a complex sentence structure.",
                "L_claude_prompt1": "In language processing, Recurrent Neural Networks (RNNs) work similarly to how we process sentences - reading them word by word. However, just as we might forget the beginning of a very long sentence by the time we reach its end, RNNs struggle to maintain information over long distances. Think of it like trying to remember the subject of a complex sentence with many embedded clauses.\n\nTo solve this memory problem, researchers developed Long Short-Term Memory (LSTM) networks, which work more like our conscious reading comprehension process. Just as we actively decide what information to keep in mind while reading a text, LSTMs have special mechanisms called \"gates\" that manage information flow.\n\nThese gates function like our cognitive processes when reading:\n- The forget gate works like our ability to discard irrelevant information (like forgetting unnecessary details in a long text)\n- The add gate is similar to how we highlight or note important information we'll need later\n- The output gate resembles how we select relevant information when answering questions about what we just read\n\nFor example, in the sentence \"The book, which was written by the author who lived in Paris during the 1920s, discusses modernist literature,\" an LSTM can maintain the connection between \"The book\" and \"discusses\" despite the long intervening relative clause, much like how we maintain coherence while parsing complex sentences.\n\nThis system allows LSTMs to handle long-distance dependencies in language, similar to how we process complex syntactic structures in natural languages."
            }
        }
    }
}